## 项目与接口分析
- 目标：实现从输入一阶逻辑表达式到量词极性输出的完整流程（词法→语法→AST→IFF 等价变换→极性分析→错误处理→测试）。
- 现有接口：
  - AST 类型与构造函数原型在 `syntax.h:18-44`、`syntax.h:86-96`。
  - 资源释放接口在 `syntax.h:98-101`。
  - 逻辑变换与极性分析接口在 `syntax.h:104-109`（`clone_prop`、`expand_iff`、`analyze_polarity`）。
  - Bison/Flex 入口在 `syntax.h:110-114`（`yyparse`、`yyerror`、`g_root`）。
- 与计划书一致性：计划书要求递归下降解析器与 AST 构建、IFF 展开与极性分析，均与现有头文件接口匹配；需补齐实现与构建系统。

## 模块划分
- 词法模块：提供统一 token 流，支持 ASCII/Unicode、`->`/`<->` 等多字符符号。
- 递归下降解析器：按优先级解析并产生 AST；对错误位置与期望符号进行报告。
- AST 构造与释放：实现 `new_*` 与 `free_*`，确保无泄漏、无共享导致的 double free。
- 逻辑变换：递归展开 IFF 为 `(φ→ψ) ∧ (ψ→φ)`；提供深拷贝 `clone_prop` 用于安全构造。
- 极性分析：按根正、否定翻转、蕴含左负右正、合/析保持等规则输出量词极性。
- 驱动与输出：读取表达式，解析→变换→分析，打印量词极性；可选打印 AST/中间结果用于调试。

## 源码与目录结构
- 根目录：
  - `syntax.h`（已存在）
  - `src/ast.c`：`new_*`/`free_*`/辅助深拷贝基础。
  - `src/lexer.l`：Flex 规则，生成 token 与语义值（标识符/数字/符号）。
  - `src/parser.y`：Bison 外壳，仅负责调用我们自写的递归下降入口并设置 `g_root`；或作为空壳提供 `yyparse` 与错误处理。
  - `src/rdparser.c`：递归下降实现（`parse_formula` 等）与 token 管理（`peek`/`consume`）。
  - `src/transform.c`：`clone_prop`、`expand_iff`。
  - `src/polarity.c`：`analyze_polarity`。
  - `src/main.c`：CLI 读取输入，串起各阶段并输出结果。
  - `CMakeLists.txt`：跨平台构建（Windows 使用 winflexbison）。
  - `tests/`：示例输入与期望输出。

## 词法设计（Token 集与规则）
- 标识符：`[A-Za-z_][A-Za-z0-9_]*`（变量/函数/谓词统一识别，由解析阶段决定角色）。
- 数字常量：`[0-9]+`。
- 括号与逗号：`(`、`)`、`,`。
- 逻辑符号：
  - 否定：`¬` 与 `!`（可选）。
  - 合取：`∧` 与 `&`（可选）。
  - 析取：`∨` 与 `|`（可选）。
  - 蕴含：`→` 与 `->`（必须整体识别）。
  - IFF：`↔` 与 `<->`（必须整体识别）。
- 量词：`∀`、`∃`；后续解析要求紧随变量与点号 `.`。
- 空白：跳过；非法字符：报错并携带位置。
- 统一映射：将 ASCII/Unicode 统一映射为内部枚举，解析器仅处理一种集合。

## 语法与递归下降实现
- 优先级（低→高）：`↔` < `→` < `∨` < `∧` < `¬` < 原子/括号/量词。
- 函数接口建议：
  - `Prop* parse_formula();`
  - `Prop* parse_imply();`、`Prop* parse_or();`、`Prop* parse_and();`、`Prop* parse_unary();`
  - `Prop* parse_quantified();`（匹配 `∀|∃ IDENT '.' Formula`）。
  - `Prop* parse_atom_or_paren();`、`UPredicate* parse_predicate();`
  - `Term* parse_term();`、`Term** parse_term_list(int* n);`
- Token 管理：
  - `Token peek()` / `Token next()` / `bool consume(expected)`；保留当前/下一个 token，支持错误恢复的最小策略（例如在右括号缺失时报具体位置）。
- 构造 AST：严格设置 `Prop.type`/`Term.type`，所有节点用 `malloc`，子节点正确挂接；解析失败返回 `NULL` 并清理已分配资源。

## IFF 等价变换与安全性
- `expand_iff(const Prop* p)`：
  - 递归遍历；遇到 `Prop_IFF` 构造 `(p1→p2) ∧ (p2→p1)`；其余保持结构但深拷贝。
  - 使用 `clone_prop` 保证不共享子树；避免释放与修改冲突。

## 量词极性分析
- `analyze_polarity(Prop* p, bool positive)`：
  - 根调用 `positive=true`。
  - `Prop_Unop(Prop_NOT)`：翻转极性后递归。
  - `Prop_Binop(Prop_IMPLY)`：左递归 `positive=false`，右递归 `positive=true`。
  - `Prop_Binop(Prop_AND/Prop_OR)`：两侧保持当前极性。
  - `Prop_Quant`：记录当前极性与变量名；递归其体。
  - `Prop_Atom`：忽略（无量词）。
- 输出格式：逐行 `∀x : positive/negative` 或 `∃y : positive/negative`；保持出现顺序或去重（可选）。

## 错误处理与内存管理
- 解析错误：包含位置、期望/实际 token 描述；在 `yyerror` 与解析器内统一输出。
- 内存：实现 `free_term`/`free_function`/`free_predicate`/`free_prop` 的递归释放；任何失败路径即时释放已分配节点。
- 防御式编程：不假设枚举整数值（仅比较枚举名），避免跨枚举值的隐式依赖。

## 构建系统与依赖
- 构建选型：CMake（跨平台），外加 Windows 指南（winflexbison）。
- 依赖：`flex`、`bison`、C 标准库；Windows 可安装 `winflexbison` 或使用 MSYS2/WSL。
- CMake 目标：
  - 生成 `lexer.c`/`parser.c` 并参与编译；链接 `ast.c`、`rdparser.c`、`transform.c`、`polarity.c`、`main.c`。
  - 提供 `BUILD_TESTING` 开关与 `ctest` 集成（可选）。
- 手工编译（备选）：
  - `win_flex --wincompat src/lexer.l` → `lexer.c`；`win_bison -d src/parser.y` → `parser.c`/`parser.h`。
  - `gcc -O2 -o fol lexer.c parser.c src/*.c`。

## 测试与验证
- 覆盖用例来自计划书第 5 节：原子、否定、量词、IFF 展开、极性、嵌套、错误输入。
- 测试方式：
  - 单元测试：为 `expand_iff` 与解析优先级写最小断言程序。
  - 端到端：读取 `tests/*.fol`，输出量词极性，与期望 `.out` diff。
- 调试辅助：提供 `--print-ast`/`--tokens` 选项（可选）。

## 实施顺序（里程碑）
1. 词法实现与 token 打印（验证 ASCII/Unicode 与多字符运算符）。
2. 递归下降解析器（从原子/括号→一元→合取→析取→蕴含→IFF）。
3. AST 构造与释放完整打通，跑最小样例。
4. IFF 展开与深拷贝实现；对 `P(x)↔Q(x)` 验证。
5. 极性分析输出；对 `(∀x.P)→((∀y.Q)∧(∃z.R))` 验证。
6. 完整错误输入集与恢复策略；内存泄漏检查。
7. 测试集与文档收尾。

## 交付物
- 可执行程序 `fol`（或 Windows 下 `fol.exe`）。
- 源码与 CMake 构建脚本；Windows 构建指引。
- 测试用例与期望输出；基本文档说明（编译运行、语法/AST/极性规则）。