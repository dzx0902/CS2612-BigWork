# 一阶逻辑语法分析与量词极性判断 —— 项目计划书（plan.md）

本项目目标是构建一个完整的一阶逻辑表达式处理器，包括词法分析、语法分析、抽象语法树构建、公式等价变换以及量词极性判断，并提供完整测试样例和文档。项目基于 Flex/Bison 提供基础 token/语法框架，但 **解析逻辑本身由我们自行实现（递归下降 parser）**。  
该计划书按课程评分标准（8 分功能 + 2 分文档）撰写，确保功能覆盖全面且结构清晰。

---

# 1. 项目目标

实现从“输入一阶逻辑表达式”到“输出量词正负出现分析”的完整处理流程，包含：

1. **词法分析（Lexer）**：识别并生成标记（Token）
2. **语法分析（Parser）**：基于递归下降方法解析一阶逻辑表达式
3. **AST 构建（基于 syntax.h）**：构造 Prop、Term、Predicate、Function 节点
4. **公式变换**：将 IFF（↔）转换为等价的 IMPLY 结构
5. **量词极性判断**：输出每个量词的正出现 / 负出现位置
6. **错误处理与边界情况覆盖**
7. **撰写测试文件与说明文档**

> 虽然使用 Flex/Bison，但核心解析逻辑（优先级、构造 AST）必须由我们手写完成。

---

# 2. 核心功能（决定 8 分功能能否拿满）

## 2.1 词法分析（Lexical Analysis）

词法分析负责将输入字符串切分成 token。必须支持：

### **Token 类型**
- **变量（identifier）**：如 `x`, `y1`, `t_2`
- **常量数字（number）**：如 `1`, `42`
- **函数名 / 谓词名**：如 `f`, `P`, `Q1`
- **括号符号**：`(`, `)`
- **逗号**：`,`
- **逻辑符号（两类表示）**  
  - Unicode：`¬`, `∧`, `∨`, `→`, `↔`  
  - ASCII：`->`, `<->`
- **量词符号**：`∀`, `∃`
- **空白字符**：自动跳过

### **关键要求**
- 正确识别 **多字符符号**：  
  `->`、`<->` 必须整体识别为 token
- 支持 ASCII/Unicode 混合输入
- 遇到非法字符必须报错（不可生成错误 token）

---

## 2.2 简单递归下降 Parser（Simple Recursive Parser）

虽然 Bison 会提供基本框架，但 **实际语法解析逻辑由我们手写实现**，要求结构清晰、仅针对一阶逻辑表达式设计。

### 支持解析的结构
- 原子公式：`P(x)`, `Q(f(x,y))`
- 函数项：`f(x)`, `g(h(k(a)))`
- 变量与常量
- 逻辑连接词：
  - 否定：`¬φ`
  - 合取：`φ ∧ ψ`
  - 析取：`φ ∨ ψ`
  - 蕴含：`φ → ψ` / `φ -> ψ`
  - IFF：`φ ↔ ψ` / `φ <-> ψ`
- 量词:
  - `∀x. φ`
  - `∃y. φ`
- 括号表达式：`( φ )`

### 运算符优先级（从低到高）
1. ↔  
2. →  
3. ∨  
4. ∧  
5. ¬  
6. 原子 / 括号 / 量词  

必须严格遵循，否则整个 AST 都会错误。

### 递归下降结构（推荐）
```
Formula       := ImplyExpr
ImplyExpr     := OrExpr (("→" | "↔") OrExpr)*
OrExpr        := AndExpr ("∨" AndExpr)*
AndExpr       := UnaryExpr ("∧" UnaryExpr)*
UnaryExpr     := "¬" UnaryExpr
               | Quantified
               | AtomOrParen

Quantified    := ("∀" | "∃") IDENT "." Formula

AtomOrParen   := Predicate | "(" Formula ")"

Predicate     := IDENT "(" TermList ")"

TermList      := Term ("," Term)*

Term          := IDENT
               | NUMBER
               | IDENT "(" TermList ")"
```

---

## 2.3 AST 构建（基于 syntax.h）

Parser 解析后需构造 Prop / Term / UPredicate / UFunction 节点，严格遵守：

- Prop.type 必须正确设置（Binop/Unop/Quant/Atom）
- Term.type 必须对应变量/常量/函数项
- 每个节点使用 `malloc`，不可出现栈上结构
- children 必须正确连接

解析错误时必须返回 NULL，不能生成无效结构。

---

## 2.4 IFF ↔ 展开为标准逻辑形式

所有 `φ ↔ ψ` 必须转换为：

```
(φ → ψ) ∧ (ψ → φ)
```

要求：

- 构造 **新的** Prop 节点，不要修改旧节点导致共享危险
- 递归展开内部结构
- 展开后结构必须完全符合 binary-op 定义

---

## 2.5 量词正 / 负出现分析（Polarity Analysis）

定义极性：

- 根：正
- ¬φ：翻转极性
- φ → ψ：
  - 左：负
  - 右：正
- φ ∧ ψ / φ ∨ ψ：极性保持
- 量词：记录当前极性

输出示例：

```
∀x : negative
∀y : positive
∃z : positive
```

必须遍历整个 AST。

---

# 3. 次要特性（影响是否能从 7 分升至 8 分）

## 3.1 嵌套表达式（深度嵌套需正确处理）
如：

```
∀x. (¬P(f(g(x))) → ∃y. (Q(x,y) ∧ R(f(x,y))))
```

## 3.2 多参数函数项与多层嵌套

```
P(a, f(x), g(h(1, y)))
```

## 3.3 ASCII / Unicode 混合情况全面支持

```
P(x)->Q(y)
P(x) → Q(y)
P(x) <-> Q(y)
P(x) ↔ Q(y)
```

## 3.4 错误检测

必须拒绝：

- `P(x,)`
- `(P(x)`
- `∀x P(x`（缺少点号）
- 未闭合括号
- `f(,x)`（非法参数表）

## 3.5 内存管理

- 所有节点必须使用 malloc 分配
- 提供 AST 的递归 free 函数
- 避免共享节点导致 double free 或逻辑错误

---

# 4. 开发步骤（推荐顺序）

## 4.1 实现词法分析器（lexer）
- 识别所有 token
- 输出 token 序列表用于调试

## 4.2 实现递归下降 Parser（核心）
- 按优先级解析
- 构造完整 AST
- 对无效输入及时报错

## 4.3 构造 AST 节点
实现例如：

- `new_prop_binop()`
- `new_prop_unop()`
- `new_prop_quant()`
- `new_predicate()`
- `new_function()`
- `new_term_variable()`

## 4.4 实现 IFF 等价变换（↔ → → ∧ →）

## 4.5 实现量词极性分析器（analyze.c）

```
void analyze_polarity(Prop* p, bool positive);
```

## 4.6 编写测试样例与完整文档

---

# 5. 测试计划（覆盖所有功能）

## 5.1 原子公式
```
P(x)
Q(f(x))
```

## 5.2 否定与复合逻辑
```
¬P(x) ∧ Q(x)
```

## 5.3 带量词表达式
```
∀x. P(x)
∃y. (Q(y) ∨ R(y))
```

## 5.4 IFF 展开
```
P(x) ↔ Q(x)
```

## 5.5 量词极性测试（核心）
```
(∀x. P(x)) → ((∀y. Q(y)) ∧ (∃z. R(z)))
```

## 5.6 嵌套函数与谓词
```
P(f(g(x), y), h(1,z))
```

## 5.7 错误输入
- 缺括号
- 多逗号
- 缺点号
- 非法字符

---

# 6. 文档要求（文档 2 分必须）

提交文档必须包含：

1. 编译与运行说明
2. token 列表与词法设计
3. 语法说明（BNF）
4. AST 节点结构说明（结合 syntax.h）
5. IFF 变换方法说明
6. 量词极性分析方法说明
7. 测试样例与输出展示

---

# 7. 总结

本计划书提供了**完整、可执行、详细、结构化**的一阶逻辑处理器开发方案。  
按本计划实现，可确保课程作业获得 **功能满分 8 分 + 文档满分 2 分**。

